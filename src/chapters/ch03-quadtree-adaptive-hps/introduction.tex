\section{Introduction}
\label{sec:intro}

Elliptic partial differential equations (PDEs) arise in fluid modeling, electromagnetism, astrophysics, heat transfer, and many other scientific and engineering applications. Solving elliptic PDEs numerically can place significant computational demands on scientific codes, and so development of fast, efficient solvers continues to be an active area of research.  Efficient solvers based on finite difference or finite element methods will typically take advantage of the sparsity of the underlying linear systems and any mesh regularity.  Efficient solvers have been developed like UMFPACK \citep{davis2004algorithm} and FISHPACK \citep{swarztrauber1999fishpack} for uniform Cartesian meshes, since for these problems, the resulting linear system has a regular sparsity pattern that can be exploited.

For many applications, uniform Cartesian meshes are prohibitively expensive and so local mesh adaptivity can be used to resolve detailed solution features.  One common approach to Cartesian mesh adaptivity is the patch-based method, originally developed by Berger, Oligier and later Colella. Software libraries implementing methods related to this patch-based approach include Chombo \citep{colella2009chombo}, \amrex \citep{zhang2019amrex}, and SAMRAI \citep{hornung2006managing}. In a patch-based approach, the computational mesh is defined as a union of overlapping rectangular patches, with finer patches placed on top of coarser patches in regions where resolution for  detailed solution features is needed.  These rectangular patches are of arbitrary size, but align with mesh coordinates of the underlying coarser mesh. Proper nesting rules ensure that every patch is completely contained within coarser patches at the same coarse resolution. 

A second approach to Cartesian mesh adaptivity, and the approach used in this paper, is to construct a composite mesh by filling leaves of an adaptive quadtree with non-overlapping locally Cartesian grids of the same size. Quadrants in the quadtree are refined by subdividing the quadrant into four smaller quadrants, each occupying one quarter of the space of the larger quadrant. Similarly, coarsening occurs when four finer quadrants are replaced by a single coarser quadrant.  Every quadrant in the quadtree layout contains a mesh of the same size, but since each quadrant occupies a space determined from their level in the quadtree, the effective resolution of each grid is finer or coarser, depending on their level in the quadtree.  Adaptive, Cartesian software libraries using a tree-based approach include PARAMESH \citep{globisch1995parmesh}, FLASH-X \citep{dubey2022flash} and ForestClaw \citep{calhoun2017forestclaw}.

Solving elliptic problems on an adaptive hierarchy of meshes introduces  technical challenges that are not present with uniform Cartesian meshes. Methods that require matrix assembly are much more difficult to use on adaptive meshes, since row entries corresponding to discretizations at boundaries between coarse and fine meshes are based on non-trivial stencils.  The Hypre library \citep{falgout2002hypre} provides some tools for matrix assembly, but these tools are not immediately useful in adaptive mesh case. A more common approach is to use matrix-free methods such as multigrid or Krylov methods.  Multigrid may be particularly well suited for adaptive meshes, since the adaptive levels are automatically built into the mesh hierarchy.  \amrex, for example, makes extensive use of multigrid for their solvers \citep{zhang2019amrex}.  However, the performance of iterative solvers is largely problem dependent and also affected by irregular stencils at boundaries between coarse and fine meshes.

In \citep{gillman2014direct}, Gillman and Martinsson describe a direct solver for elliptic problems that is particularly well suited to composite quadtree meshes. In their approach, a matrix-free factorization of the linear system is constructed by merging leaf level quadrants in a uniformly refined composite quadtree mesh up to a root node of the tree. Then in a solve stage, the boundary condition data imposed on the physical domain is propagated back down the tree, where Dirichlet problems on each leaf patch can be solved using fast solvers. This approach does not require any matrix assembly on the composite mesh and can be used with any uniform grid solver at the leaf level. In their original work, Gillman and Martinsson use high-order spectral collocation methods and low-rank optimization to achieve $\mathcal O(N)$ factorization complexity \citep{gillman2014direct}.  This method has come to be known as the \HPS (HPS) method \citep{martinsson2015hierarchical}. Advancements to the HPS method include 3D and parallel implementations \citep{hao2016direct,beams2020parallel}. Applications of the HPS method can be found in \citep{fortunato2020ultraspherical}.  More details on the HPS method can be found in Chapters 19--27 of \citep{martinsson2019fast} and a tutorial on the HPS method can be found in \citep{martinsson2015hierarchical}.

The focus of this paper is on an implementation of the HPS method on an adaptive, finite volume mesh using the state-of-the-art meshing library \pforest to generate the adaptive quadtree mesh \citep{burstedde2011p4est}.  The \pforest library provides highly efficient data structures and iterators necessary for implementing the HPS method.  A feature that sets \pforest apart from other quadtree meshing libraries is that it multiblock meshes (e.g. a "forest-of-octrees"), allowing for significant flexibility in the geometry of the mesh. \pforest uses a space filling curve to partition the mesh using MPI, and provides utilities for dynamic adaptivity. \ignore{As will be outlined in \refsec{sec:adaptivity}, the use of \pforest enables efficient storage of the data required for the HPS method and provides iterators necessary for the different stages of the HPS method.}  Our work follows upon earlier work presented in \citep{babb2018accelerated, geldermans2019adaptive}.

\ignore{and a 4-1 merging strategy in place of the 2-1 merging described in in the original method.}

\subsection{Problem Statement}

We focus on the constant coefficient elliptic problem
\begin{equation}
    \nabla^2 u(x,y) + \lambda u(x,y) = f(x,y), \quad \lambda \ge 0
    \label{eq:elliptic_pde}
\end{equation}
with $(x,y) \in \Omega = [a, b] \times [c,d]$, subject to Dirichlet boundary conditions
\begin{equation}
    u(x,y) = g(x,y),\ \ (x,y) \in \Gamma = \partial \Omega.
\end{equation}
For this paper, we assume that $b-a=d-c$ so that we can describe our mesh using a single quadtree and square mesh cells.  In general though, this is not a limitation of meshes generated using the multi-block ``forest-of-octrees'' capabilities of \pforest.  The primary contributions of this paper are an HPS solver for the constant coefficient ellitpic problem on an adaptively refined \pforest mesh. In future work, we will include fast linear algebra needed to reduce the complexity of the overall algorithm to $\mathcal O(N)$, a key contribution of the original HPS method developed by Gillman and Martinsson.

In \refsec{sec:quadtree}, we describe the quadtree-adaptive HPS method, including the leaf-level computations, merging and splitting algorithms, and the handling of coarse-fine interfaces. This section also includes a comparison between our 4-to-1 approach contrasted to the 2-to-1 approach presented in \citep{gillman2014direct}. \refsec{sec:adaptivity} describes implementation details such as the data structures and functions that wrap the \pforest mesh backend. Finally, in \refsec{sec:results} we provide results of numerical experiments solving different types of elliptic PDEs, including a convergence analysis and timing results for the use of the quadtree-adaptive HPS method on adaptive meshes.
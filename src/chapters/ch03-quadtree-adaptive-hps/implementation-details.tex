\section{Implementation Details}
\label{sec:adaptivity}

In this section, we go over some of the details useful in understanding how the \gls{qahps} method is implemented. We discuss the patch solver implementation which wraps fast solvers for \refeqn{eq:elliptic-pde}. We provide details related to the mesh library \pforest which is used as a backend for the quadtree data structure \citep{burstedde2011p4est}.

\subsection{Patch Solvers}
\label{sub:patch_solvers}

When solving \refeqn{eq:elliptic-pde} on a single leaf patch, the method used to solve the \gls{bvp} is called a {\em patch solver} and we denote this function as \texttt{PatchSolver}. The goal of the patch solver is to perform the computations in \refeqn{eq:patch_leaf_solve}. The patch solver takes as input the Dirichlet data on the boundary $\textbf{g}_{ext}^{\tau}$, the inhomogeneous data $\textbf{f}^{\tau}$, and some representation of the discretization (i.e., a finite volume grid that corresponds to the patch domain). On output, \texttt{PatchSolver} returns the solution $\textbf{u}^{\tau}$ of \refeqn{eq:elliptic-pde} on the leaf patch.

Ideally, the patch solver routine takes advantage of fast and optimized solvers for the \gls{bvp} \refeqn{eq:elliptic-pde}. For constant coefficient problems, we wrap the FISHPACK routines \citep{swarztrauber1999fishpack} provided in the FISHPACK90 library \citep{adams2016fishpack90}. FISHPACK solves \refeq{eq:elliptic-pde} using a cyclic-reduction method, providing a fast and efficient solver for ``small'' problems. As we use a cell-centered discretization for use with a finite-volume code, we wrap the \texttt{hwscrt} method for our \texttt{PatchSolver}. When solving the variable coefficient problem, we wrap a patch solver written with PETSc \citep{anl2023petsc} that solves \refeqn{eq:elliptic-pde} using a five-point stencil method.

\subsection{Building Leaf Level Operators}
\label{sub:building-leaf-level-operators}

At the leaf level, two operators are required: \Stau and \Ttau. The \texttt{PatchSolver} takes the role of \Stau on the leaf. We explicitly compute the matrix \Ttau through use of the patch solver. We define a function \texttt{BuildD2N} that computes \Ttau according to \refeqn{eq:Ttau-leaf}. The \gls{d2n} matrix depends solely on the discretization -- it is independent of boundary data or inhomogenenous data. The matrix \Ttau is computed column-by-column by solving \refeq{eq:elliptic-pde} with columns of the identity matrix $\textbf{I} \in \real^{4M \times 4M}$ as Dirichlet data \gtau:
\begin{align}
\text{col}_j (\Ttau) = \Ttau \hat{\textbf{e}}_j = \frac{2}{h} (\textbf{I} - \textbf{G} \mathcal{L}_h^{\tau}) \hat{\textbf{e}}_j.
\end{align}

For a constant coefficient elliptic problem, we can take advantage of symmetry in \Ttau to reduce the number of calls to the \texttt{PatchSolver}. This is due to the limited range of the \gls{d2n} operator being a boundary operator that depends solely on the discretization of the elliptic problem. To build \Ttau using these optimizations, compute the first $M$ columns of \Ttau and use the following pattern to fill in the remaining blocks:
\begin{align}
\textbf{T}^{\tau} =
\begin{bmatrix}
    \textbf{T}_{w,w} & -\textbf{T}_{w,e} & \textbf{T}_{w,s} & -\textbf{T}_{w,n} \\
    \textbf{T}_{w,e} & -\textbf{T}_{w,w} & \textbf{T}_{w,n} & \textbf{T}_{e,n} \\
    \textbf{T}_{w,s} & -\textbf{T}_{w,n}^T & \textbf{T}_{w,w} & -\textbf{T}_{w,e} \\
    \textbf{T}_{w,n} & \textbf{T}_{w,n}^{'} & \textbf{T}_{w,e} & -\textbf{T}_{w,w} \\
\end{bmatrix}
\end{align}
where $M$ is the size of a leaf patch boundary, and $\textbf{T}_{w,n}^{'}$ is $\textbf{T}_{w,n}$ with reversed columns: $T_{i,j}^{'} = T_{M-i,j}$.

\subsection{Quadtrees and Adaptive Meshes}
\label{sub:quadtrees-and-adaptive-meshes}

As a software library, \pforest provides a quadtree data structure and functions to construct, store, and iterate over leaf-level quadrants in the quadtree \citep{burstedde2011p4est}. However, as mentioned in \refsec{sec:problem-statement}, the \gls{qahps} method requires storage for all nodes in the quadtree. This is to store the set of solution operators that act as the matrix factorization of the system matrix. Thus, we require a new data structure that allows for data storage for all nodes in a quadtree. One approach that will later prove to be advantageous for parallel applications is a {\em path-indexed quadtree} \citep{woodward1982explicit,samet1984quadtree}. The path of a node is the unique series of directions required to traverse from the root of the tree to the node. The unique path is encoded as a string containing the sequence of nodes visited.  \reffig{fig:quadtree_indexing} illustrates the path and this unique encoding for a level 3 node.

A path-indexed quadtree creates storage for all nodes in the tree through the use of a \texttt{NodeMap}, equivalent to a C++ \texttt{std::map<std::string, Node<T>*>}, where the template parameter \texttt{T} corresponds to a user-provided class to be stored at each node. The path is computed using \texttt{p4est\_quadrant\_ancestor\_id}. The path-indexed quadtree wraps functions provided by \pforest to construct and iterate over nodes.

Two functions provided by \pforest allow for a depth-first traversal of a \pforest quadtree: \texttt{p4est\_search\_all} and \texttt{p4est\_search\_reorder}. \texttt{p4est\_search\_all} performs a top-down search of the quadtree and provides a callback function with access to a \pforest quadrant data structure. This function is used to create the path-indexed quadtree from the leaf-indexed quadtree. This is done by traversing the leaf-indexed quadtree in a depth-first fashion, computing the path for each quadrant, and allocating memory for a \texttt{Node} object in the \texttt{NodeMap}.

The function \texttt{p4est\_search\_reorder} also does a top-down search, and provides pre- and post-quadrant callback functions for accessing quadrant data. Wrapping \texttt{p4est\_search\_reorder}, we define a {\em merge traversal} and a {\em split traversal} of a quadtree. The merge traversal iterates over a quadtree in a post-order fashion, visiting children then parents. When visiting a leaf, a {\em leaf callback} is supplied. When visiting parents, a {\em family callback} is used that provides access to the parent and the four children nodes. This is to ``merge'' four children nodes into a parent node. The split traversal iterates over a quadtree in a pre-order fashion, with callbacks to families then leaf nodes. This is to provide access to families to ``split'' one parent node into four children nodes. The leaf callback is done last in the split traversal and is used to compute leaf level data once the entire tree has been traversed. The algorithm for the callback function passed to \texttt{p4est\_search\_reorder} is provided in \refalg{alg:merge-split-callback-serial}.

\begin{algorithm}
\caption{\texttt{MergeSplitTraversal} Function (passed to \codename{p4est\_search\_reorder})}
\begin{algorithmic}[0]
    \Require Functions \texttt{LeafCallback}(\texttt{leaf\_node}) \& \texttt{FamilyCallback}(\texttt{parent\_node, children\_nodes})
    \State Compute \texttt{path} from \texttt{p4est\_quadrant\_ancestor\_id}
    \State Let \texttt{node = node\_map[path]}
    \If{\texttt{node} is a leaf} \Comment{Node is a leaf, call leaf callback}
        \State Call \texttt{LeafCallback(node)}
    \Else \Comment{Node is a branch, get children and call family callback}
        \For{i = 0, 1, 2, 3}
            \State \texttt{children\_nodes[i] = map[path + string(i)]}
        \EndFor
        \State Call \texttt{FamilyCallback(node, children\_nodes)}
    \EndIf
\end{algorithmic}
\label{alg:merge-split-callback-serial}
\end{algorithm}

For the build stage of the \gls{qahps} method, the leaf callback is \texttt{BuildD2N}, which solves \refeqn{eq:Ttau-leaf} to explicitly compute a leaf level \gls{d2n} matrix (see \refsec{sub:leaf_level_computations}). The family callback for the build stage is \refalg{alg:build_merge}. For the upwards stage, the leaf callback computes \htau according to \refeqn{eq:htau-leaf}. The family callback is \refalg{alg:upwards_merge}. These are performed in a post-order fashion in the merge traversal.

For the solve stage, the split traversal is done in a pre-order fashion. The family callback for the solve stage is \refalg{alg:solve_split}. The leaf callback calls \texttt{PatchSolver} to solve the \gls{bvp} using fast solvers.
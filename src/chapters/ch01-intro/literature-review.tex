\section{Literature Review}

This section will detail the current state of the field regarding solvers for elliptic \gls{pdes}. \damyn{[More here.]}

\subsection{Fast Solvers for Elliptic PDEs}

The linear systems formed by discretizations of elliptic \gls{pdes} are sparse and banded. Numerical linear algebra techniques that take advantage of this structure are ideal. Efficient solvers have been developed for uniform Cartesian meshes, such as the Unsymmetrical Multifrontal method implemented in the UMFPACK code \citep{davis2004algorithm} or the Cyclic Reduction method \citep{swarztrauber1974direct} as implemented in the FISHPACK library \citep{swarztrauber1999fishpack,adams2016fishpack90}.

\citet{gillman2014direct} describe a direct solver for elliptic problems on a binary tree structure. The goal is to build up a factorization by successively merging subdomains via a class of Poincar\'e-Steklov operators \citep{quarteroni1991theory} called \gls{d2n} operators. It is a domain decomposition method that was originally inspired by the partitioning scheme of nested dissection \citep{george1973nested,lipton1979generalized}. This approach does not require any matrix assembly on the composite mesh and can be used with any uniform grid solver at the leaf level. In their original work, \citet{gillman2014direct} use high-order spectral collocation methods and low-rank optimization to achieve $\mathcal O(N)$ factorization complexity. This method has come to be known as the \gls{hps} method \citep{martinsson2015hierarchical}. The \gls{hps} method has been applied to solve 3D elliptic \gls{pdes} \citep{hao2016direct}, has been coupled with the spectral element method \citep{fortunato2020ultraspherical}, and implemented on adaptive meshes \citep{babb2018accelerated, geldermans2019adaptive,chipman2024fast}. Recently, the \gls{hps} method has also been implemented in parallel, targeting shared-memory machines \citep{beams2020parallel}, distributed-memory machines \citep{yesypenko2022parallel}, and \gls{gpu} devices \citep{yesypenko2022gpu}. More details on the \gls{hps} method can be found in Chapters 19--27 of \citep{martinsson2019fast} and a tutorial on the \gls{hps} method can be found in \citep{martinsson2015hierarchical}. A more in-depth description of the \gls{hps} method outlined by \citet{gillman2014direct} will be provided in \refsec{subsub:hps-method}.

\damyn{[Should I look into integral formulations of elliptic PDEs? FMM?]}

\damyn{[Direct vs. iterative solvers discussion.]}

\subsection{Adaptive Mesh Refinement for Elliptic PDEs}

For many applications, uniform Cartesian meshes are prohibitively expensive and so local mesh adaptivity can be used to resolve detailed solution features.  One common approach to Cartesian mesh adaptivity is the patch-based method, originally developed by Berger, Oligier and later Colella \damyn{[TODO: Find references for original AMR methods.]}. Software libraries implementing methods related to this patch-based approach include Chombo \citep{colella2009chombo}, \amrex \citep{zhang2019amrex}, and SAMRAI \citep{hornung2006managing}. In a patch-based approach, the computational mesh is defined as a union of overlapping rectangular patches, with finer patches placed on top of coarser patches in regions where resolution for  detailed solution features is needed.  These rectangular patches are of arbitrary size, but align with mesh coordinates of the underlying coarser mesh. Proper nesting rules ensure that every patch is completely contained within coarser patches at the same coarse resolution.

A second approach to Cartesian mesh adaptivity, and the approach used in this paper, is to construct a composite mesh by filling leaves of an adaptive quadtree with non-overlapping locally Cartesian grids of the same size. Quadrants in the quadtree are refined by subdividing the quadrant into four smaller quadrants, each occupying one quarter of the space of the larger quadrant. Similarly, coarsening occurs when four finer quadrants are replaced by a single coarser quadrant.  Every quadrant in the quadtree layout contains a mesh of the same size, but since each quadrant occupies a space determined from their level in the quadtree, the effective resolution of each grid is finer or coarser, depending on their level in the quadtree.  Adaptive, Cartesian software libraries using a tree-based approach include PARAMESH \citep{globisch1995parmesh}, FLASH-X \citep{dubey2022flash} and ForestClaw \citep{calhoun2017forestclaw}.

\damyn{[TODO: Include figure depicting patch-based vs. tree-based AMR methods.]}

Solving elliptic problems on an adaptive hierarchy of meshes introduces technical challenges that are not present with uniform Cartesian meshes. Methods that require matrix assembly are much more difficult to use on adaptive meshes, since row entries corresponding to discretizations at boundaries between coarse and fine meshes are based on non-trivial stencils.  The Hypre library \citep{falgout2002hypre} provides some tools for matrix assembly, but these tools are not immediately useful in adaptive mesh case. A more common approach is to use matrix-free methods such as multigrid or Krylov methods.  Multigrid may be particularly well suited for adaptive meshes, since the adaptive levels are automatically built into the mesh hierarchy. \amrex, for example, makes extensive use of multigrid for their solvers \citep{zhang2019amrex}.  However, the performance of iterative solvers is largely problem dependent and also affected by irregular stencils at boundaries between coarse and fine meshes.

\subsection{Parallelism and Software}

Parallel linear solvers using iterative or direct methods have been successfully developed and implemented. Parallel iterative methods include GMRES \citep{saad1986gmres}, the conjugate gradient method \citep{hestenes1952methods}, the \gls{amg} method \citep{yang2002boomeramg}, and the \gls{gmg} method \citep{sundar2012parallel} (with a good overview provided by \citet{chow2006survey}). Parallel direct methods include matrix factorization methods like LU-factorization, Cholesky factorization and the spectral value decomposition \citep{donfack2015survey, demmel1999asynchronous, gupta1997highly}.

Several, large-scale and open-source codes currently exist to solve linear systems formed from elliptic PDEs. The hypre library \citep{falgout2002hypre} features scalable preconditioners for parallel multigrid methods. The SuperLU library \citep{li2005superlu} is a general purpose library for solving sparse linear systems using direct methods. Additional codes like PETSc \citep{anl2023petsc}, FLASH-X \citep{dubey2022flash}, and AMReX \citep{zhang2019amrex}, contain iterative and direct solvers that also work with \gls{amr}. The ForestClaw code \citep{calhoun2017forestclaw} coupled with the ThunderEgg repository \citep{aiton2022thunderegg} implements hyperbolic and elliptic solvers for finite volume meshes on adaptively refined quadtrees and octrees provided from \pforest. \pforest\ \citep{burstedde2011p4est,burstedde2020parallel} is a highly scalable AMR code that provides quadtree and octree data structures for users to build on top of. The EllipticForest library \citep{chipman2024ellipticforest} contains an implementation of the quadtree-adaptive HPS method, including the parallel algorithms outlined in this paper. Another code of interest is the ButterflyPACK library \citep{liu2018butterflypack} that solves large-scale dense systems with off-diagonal, low-rank structure like the matrices formed in the HPS method.
\section{The Adaptive Rebuild Algorithm}
\label{sec:adaptive-rebuild-algorithm}

\subsection{Theory for the Adaptive Rebuild}

We wish to solve \refeqn{eq:elliptic-pde} subject to Dirichlet boundary conditions and/or Neumann boundary conditions. As outlined in \refsec{sec:quadtree}, we partition the domain $\Omega$ into a composite collection of subdomains $\Omega_i$ which is organized into a leaf-indexed quadtree $\mathcal{Q}_{L}$ and a path-indexed quadtree $\mathcal{Q}_{P}$. We express explicit dependence of $\mathcal{Q}_{P}$ for the set of solution operators $\mathcal{S}$, which is built up using the algorithms outlined in \refchap{chap:qahps}.

Suppose an initial mesh is created, which we denote with $\mathcal{Q}^{k}_{L}$ and $\mathcal{Q}^{k}_{P}$ (the path-indexed quadtree is created from the leaf-indexed quadtree). This allows for the creation of a solution operator set $\mathcal{S}^{k}$. Recall the refinement criteria
\begin{align}
    T_{R} (\textbf{x}) =
    \begin{cases}
        1,& \eta(\textbf{x}) > \epsilon_{R} \\
        0,& \text{otherwise},
    \end{cases}
\end{align}
and the coarsening criteria
\begin{align}
    T_{C} (\textbf{x}) =
    \begin{cases}
        1,& \eta(\textbf{x}) < \epsilon_{C} \\
        0,& \text{otherwise},
    \end{cases}
\end{align}
for $\textbf{x} \in \Omega_i$. Now, the mesh is adapted by iterating over all leaf nodes and checking the refinement and coarsening criteria for all subdomains $\Omega_i$ in $\mathcal{Q}_{L}$, resulting in $\mathcal{Q}^{k+1}_{L}$ and $\mathcal{Q}^{k+1}_{P}$. The updated solution operator set $\mathcal{S}^{k+1}$ is amended based on each refinement or coarsening. When refining, $\mathcal{S}^{k}$ is supplemented by traversing up the levels in the tree to update the direct ancestors of the tagged nodes to produce $\mathcal{S}^{k+1}$. When coarsening, the operators corresponding to the coarsened group of siblings are removed from $\mathcal{S}^{k}$, then each ancestor is updated to produce $\mathcal{S}^{k+1}$. When updating the ancestors of the tagged nodes, the same 4-to-1 merge algorithm outlined in \refalg{alg:build_merge} is used, just on a per-level basis for each direct ancestor. Any coarse-fine interfaces that are introduced during this mesh adaptation are handled using the same ``coarsen patch'' approach outlined in \refsec{sub:mesh_adaptivity}.

For an initial mesh, the build, upwards, and solve stages need to be called for the entire mesh. Subsequent solves only need to call the upwards and the solve stages. When the mesh is adapted, the factorization set is updated accordingly. We note that technically the upwards stage (i.e., computing \htau and \wtau) could also be done incrementally; however, since right-hand side data is likely to have changed with the newly adapted mesh, we choose to call the upwards stage for each solve.

\subsection{Propagating Up a Quadtree}

When a node is tagged for coarsening or refinement and then adapted accordingly, the direct ancestors of the tagged node must also be updated. We do this through a {\em propagate} algorithm. The propagate algorithm updates the ancestors of a tagged node by iterating up the levels in the quadtree and calling a family callback for each direct ancestor. From \reffig{fig:adaptive-tree-rebuild-01}, these are the orange nodes, with the green nodes supplying their data as part of the family callback.

\refalg{alg:propagate} contains the algorithm for the propagate function. This iterates up the tree level-by-level by successively removing the last index of the path, then gathering the family of nodes that participate in the family callback. Recall that the family callback is a function called while traversing a path-indexed quadtree that supplies the user references to a family of nodes (the parent node and the four children nodes). For the \gls{qahps} method, the family callback supplied to this is \refalg{alg:build_merge}, the 4-to-1 merge algorithm.

\begin{algorithm}
    \caption{\codename{Propagate} Function}
    \begin{algorithmic}[0]
        \Require Tagged Node: $\tau$, \codename{FamilyCallback(parent\_node, children\_nodes)}
        \State Let \codename{path} be the path of the tagged node (represented as a string or array of characters)
        \State Let \codename{map} be the key-value lookup table between a path and the node
        \State Call \codename{PopBack(path)} \Comment{Remove the last character of the path}
        \While{\codename{Length(path)} $> 0$}
            \State Let \codename{parent\_node} = \codename{map[path]}
            \State Let \codename{children\_nodes} = \codename{ComputeChildrenNodes(parent\_node)}
            \State Call \codename{FamilyCallback(parent\_node, children\_nodes)}
            \State Call \codename{PopBack(path)}
        \EndWhile
    \end{algorithmic}
    \label{alg:propagate}
\end{algorithm}

When refining or coarsening a node, the propagate function gets called during the initialization of the newly created refined nodes or newly created coarsened node.

% For applications where the factorization set is used multiple times (time dependent problems, multiple right-hand sides, etc.), the build stage is called only after the creation of an initial mesh. When the 